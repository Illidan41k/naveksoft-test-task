общие замечания по коду:
1) горизонтальность. В одной строке по 2 и более действия.
Там, где в одной строке по 5-6 условий или инициализаций - ещё ок. просто нечитаемо, но не более.
Но есть места, где вызываются методы, в которые как аргументы передаются в той же строке на ходу создаваемые объекты.
А это уже, как известно, UB.
2) много не говорящих сами за себя имён. fr, sf, hdr, ch, sa, cdsn и прочее.
3) методы перегружены логикой. напрашивается дробление на более мелкие логические составляющие.
4) копипасто-ориентированное программирование everywhere.
пункты 4 и 5 на самом деле взаимосвязаны. От обеих проблем  можно избавиться за раз, если вынести многократно копируемые одинаковые строки в
отдельные методы.
5) большая вложенность циклов и условий.
6) немало остатков закомменченных кусочков. 
Закомменченые строки возникают обычно, когда надо наспех одну логику заменить другой.
Но когда условие "наспех" заканчивается, с этим надо что-то делать:
а) если старая логика гарантированно не нужна - снести не жалея. Если что, гит всё помнит, найти несложно.
б) если старая и новая логика опциональны - ввести инструменты для этой опциональности
в) по ситуации может быть что-то третье. Но точно не оставлять сотни отдельных закомменченых строк в рабочем коде.

----------------------------------------------------------------------------------------------------------------------------------------------
рандомные странные места, которые стоит упомянуть подробнее:
1) 
static inline char hex(int v) {
	static const char alpha[]{ "0123456789abcdef" };
	return alpha[v];
}
необходима проверка аргумента на попадание в диапазон [0, 15]
2) 
в нескольких местах встречено
	catch (std::exception& ex) {

	}
лучше уже не ловить, чем ловить и не давать об этом информации ни в лог, ни куда-то ещё. Эксепшены должны быть
действительно ИСКЛЮЧИТЕЛЬНЫМИ случаями, о которых уж точно нужно давать знать.
3)
		auto&& token{ app->AccessToken(request["origin"].get<std::string>(), request["channel"].get<std::string>(), request["ttl"].is_number() ? request["ttl"].get<size_t>() : 0) };
		ApiResponse(fd, "200", token);
Учитывая, что AccessToken может отдавать пустой токен, где-то должна быть проверка на его пустоту.
Может, для этого брокера отдать пустой токен доступа нормально, но со стороны так не выглядит :)
P.S. для токена сессии такой проблемы нет. там пустой токен отдаться не может. Что ещё раз усиливает подозрения в отношении  AccessToken
4)
обёртку для джейсона (класс cjson) в идеале бы сделать с использованием PIMPL. Видно, что нлохман в проекте использовался не сразу, до этого была
другая библиотека. Значит, минимум 1 раз возникала необходимость перекомпиляции всего кода, т.к. не использована PIMPL. 
Это может быть проблемой при масштабировании решения.
5) csmppservice.cpp - первый кандидат на рефактор. 29 классов в одном файлике  - очень внушительно :)
В совокупности с методом на 100+ строк и максимальной вложенностью логики в 6 подуровней.

